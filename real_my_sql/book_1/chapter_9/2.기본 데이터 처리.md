# 9.2.기본 데이터 처리
## 9.2.1 풀 테이블 스캔과 풀 인덱스 스캔
- 풀 테이블 스캔을 사용하는 경우
1. 테이블 레코드 건수가 적어서 인덱스보다 풀 테이블 스캔이 더 빠를 때
2. WHERE, ON 절에 적절한 인덱스 없는 경우
3. 인덱스 레인지 스캔을 사용할 수 있는 쿼리지만 조건 일치 레코드 건수가 너무 많은 경우

- 풀 테이블 스캔의 경우 페이지를 한번에 몇 개씩 가져오나?
    - InnoDB의 경우 백그라운드 스레드에서 리드 어헤드(read ahead) 작업을 함
    - 리드 어헤드(read ahead): 어떤 영역의 데이터가 필요할지 예측해 버퍼 풀에 저장해두는 것
    - 포그라운드 스레드 -> 백그라운드 스레드로 읽기 작업 넘김 (최대 64개 페이지까지 읽어서 저장)
    - 포그라운드 스레드는 버퍼풀에 저장된 데이터를 가져옴
    - innodb_read_ahead_threshold 시스템 변수: 언제 리드 어헤드를 시작할 지 임계값 설정. 이 시스템 변수에 설정된 개수만큼 연속된 페이지가 읽히면 버퍼 풀로 적재 시작

    ```sql
    SHOW VARIABLES LIKE 'innodb_read_ahead_threshold';
    ```

## 9.2.2 병렬 처리
- 하나의 쿼리를 여러 스레드가 작업을 나누어 동시에 처리하는 것
- innodb_parallel_read_threads 시스템 변수: 하나의 쿼리를 최대 몇 개의 스레드를 이용해 처리할지
- MySQL 8.0 에서는 WHERE 조건 없이 단순히 테이블 전체 건수를 가져오는 쿼리만 병렬 처리 가능
    ```sql
    SELECT count(*) FROM employees;
    ```

## 9.2.3 ORDER BY 처리(Using filesort)
1. 인덱스 이용
2. Filesort 이용 (실행계획에서 Extra 컬럼에 "Using filesort"라고 표시됨)
- 모든 정렬을 인덱스로 하지 못하는 이유는 뭘까?
    1. 정렬 기준이 너무 많은 경우
    2. GROUP BY / DISTINCT 처리 결과를 정렬해야 하는 경우
    3. UNION 과 같이 임시 테이블의 결과를 정렬해야 하는 경우
    4. 랜덤하게 레코드를 가져와야 하는 경우

### 9.2.3.1 소트 버퍼
- sort_buffer_size 시스템 변수로 소트 버퍼의 크기를 설정 가능
- 정렬해야 할 레코드 건수가 소트 버퍼 공간보다 큰 경우
    => 디스크에 임시 저장하게 됨
    => 이후 버퍼에 정렬된 레코드와 머지해서 정렬 수행: 멀티 머지(Multi-merge)
- 멀티 머지 횟수는 Sort_merge_passes 라는 상태 변수에 누적해서 집계 됨

- 소트 버퍼 크기를 크게 설정하면 되지 않나?
    - 실제 벤치마크 결과 큰 차이를 보이지 않음.
    - 저자에 따르면 소트 버퍼의 크기 256KB ~ 8MB 사이가 최적의 성능을 보였음.   
    - 소트 버퍼는 글로벌 메모리 영역(x), 세션 메모리 영역(o), 즉 클라이언트 마다 생기는 메모리 영역이므로 과도하면 메모리 공간이 부족해짐

### 9.2.3.2 정렬 알고리즘
- 정렬 대상이 되는 컬럼만 가져오는지 여부에 따라 싱글 패스(Single-pass) vs. 투 패스(Two-pass)

#### 9.2.3.2.1 싱글 패스 정렬 방식
- 정렬에 필요하지 않은 컬럼까지 전부 소트 버퍼에 담고 정렬 수행
- 더 큰 소트 버퍼의 크기가 필요함
- 최신 버전에서 사용
- 정렬 대상 레코드의 크기가 건수가 작은 경우 빠름

#### 9.2.3.2.2 투 패스 정렬 방식
- 싱글 패스와 반대
- 싱글 패스 이전에 사용하던 방식
- 특정 조건에서는 여전히 투 패스 방식 사용
- 테이블을 2번 읽어야 함
- 정렬 대상 레코드의 크기나 건수가 많은 경우 효율적




