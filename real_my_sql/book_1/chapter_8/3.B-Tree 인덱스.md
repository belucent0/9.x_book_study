# 8.3 B-Tree 인덱스
- B-Tree = Balanced Tree
## 8.3.1 구조 및 특성
- 루트 노드 - 브랜치 노드 - 리프 노드: 리프노드에는 항상 실제 데이터 레코드의 주소값이 있음
- 데이터 파일의 레코드는 INSERT된 순서대로 저장된다?
    - ❌️ 만약 테이블의 레코드를 전혀 삭제하거나 변경하지 않고 INSERT만 수행한다면 맞을 수도 있음. BUT 레코드가 삭제되어 빈 공간이 생기면 -> 공간을 재활용할 수 있음
## 8.3.2 B-Tree 인덱스 키 추가 및 삭제
### 8.3.2.1 인덱스 키 추가
- 새로운 키 값이 B-Tree에 저장될 때 새로운 키 값이 즉시 인덱스에 저장된다?
    - 그럴 수도 아닐 수도 있음.
    - INSERT, UPDATE 시 인덱스가 있는 경우 작업 비용은 1.5배 정도로 예상할 수 있음. (디스크로부터 인덱스 페이지를 읽고 쓰는 시간)
    - MEMORY, MYISAM 에서는 즉시 새로운 키 값을 B-Tree 인덱스에 변경
    - InnoDB 에서는 지연시켜서 나중에 처리 가능. BUT PK, 유니크 인덱스는 중복 체크가 필요하므로 즉시 추가/삭제.
### 8.3.2.2 인덱스 키 삭제
- 삭제하는 경우?
    - 리프 노드에서 삭제 마크만 진행. 간단함. 디스크 I/O 가 필요한 작업이긴 함.
### 8.3.2.3 인덱스 키 변경
- 키 값 변경 안됨. 삭제 후 새롭게 추가해야 함.
- **8.3.2.4 인덱스 키 검색**
    - update, delete 문제 실행 시 인덱스가 없으면 불필요하게 많은 레코드를 잠금. 테이블의 모든 레코드를 잠글 수도 있음.
## 8.3.3 B-Tree 인덱스 사용에 영향을 미치는 요소
### 8.3.3.1 인덱스 키 값의 크기
    - 인덱스의 페이지 크기를 정할 수 있는 시스템 변수: innodb_page_size (4KB~64KB, 기본 16KB)
- 페이지 수가 늘어나면 최소한 2번 이상 디스크로부터 읽어야 함.
### 8.3.3.2 B-Tree 깊이
- 제어 불가. 5단계 이상 깊어지는 경우 흔치 않음.
### 8.3.3.3 선택도(기수성)
- 모든 인덱스 키 값 가운데 유니크한 값의 개수
### 8.3.3.4 읽어야 하는 레코드의 건수
## 8.3.4 B-Tree 인덱스를 통한 데이터 읽기
### 8.3.4.1 인덱스 레인지 스캔
- 인덱스의 범위가 결정됐을 때 사용 (where ~ between ~ and ~)
### 8.3.4.2 인덱스 풀 스캔
- 인덱스의 처음부터 끝까지 읽는 방법
- 쿼리의 조건절이 인덱스 칼럼의 순서로 시작하지 않는 경우 실행됨.
- 테이블 풀 스캔보다 좋고, 인덱스 레인지 스캔보다는 안 좋음.
### 8.3.4.3. 루스 인덱스 스캔
- 인덱스를 루즈하게 읽는 것을 의미함.
- 인덱스 중간에 필요하지 않은 키값은 무시하고 스킵함.
- 예시 쿼리
    - dept_no, emp_no 두 칼럼으로 인덱스가 생성된 경우
        ```sql
        SELECT dept_no, MIN(emp_no)
        FROM dept_emp
        WHERE dept_no BETWEEN 'd002' AND 'd004'
        GROUP BY dept_no;
        ```
### 8.3.4.4. 인덱스 스킵 스캔
- 인덱스 컬럼 순서대로 작성되지 않은 쿼리도 최적화시켜주는 기능
- MySQL 8.0 부터 다음 세팅으로 ON/OFF 가능
    ```sql
    SET optimizer_switch='skip_scan=off' # 비활성화
    SET optimizer_switch='skip_scan=on' # 활성화
    ```
- 실행계획에 type: range / Extra: Using index for skip scan 이 나타나는 경우 이 세팅이 작용한 것
- 다음 조건을 만족해야 함
    1. 커버링 인덱스
    2. WHERE 조건절에 조건이 없는 선행 컬럼의 유니크한 값의 개수가 적어야 함.
    M / F -> 2개
## 8.3.5 다중 칼럼 인덱스
## 8.3.6 B-Tree 인덱스의 정렬 및 스캔 방향
- 인덱스는 오름차순/내림차순으로 생성
### 8.3.6.1 인덱스의 정렬
#### 8.3.6.1.1 인덱스 스캔 방향
- 인덱스 생성 시점에 오름차순/내림차순이 결정되어 있어도 쿼리가 인덱스를 사용하는 시점에 정순/역순 방향을 결정한다.
- 역순/정순 스캔 여부는 옵티마이저가 결정함.
### 8.3.6.1.2 내림차순 인덱스
- 역순 스캔이 더 속도가 느림.
- 다중 칼럼 인덱스의 경우 정렬 순서를 혼합해서 생성할 수 있음. (8.0 이전에는 오름차순만 가능했음.)

## 8.3.7 B-Tree 인덱스의 가용성과 효율성
### 8.3.7.1 비교 조건의 종류와 효율성
- 작업 범위 결정 조건: 작업의 범위를 결정하는 조건 -> 성능 개선에 중요
- 필터링 조건(체크 조건): 작업의 범위를 줄이지는 못하고 단순히 필터링만 하는 조건 -> 체크 조건이 많은 경우 속도가 느려질 수 있음

### 8.3.7.2 인덱스의 가용성
- 다중 컬럼 인덱스의 경우 선행 컬럼에 따라 후행 컬럼이 정렬된다.

### 8.3.7.3 가용성과 효율성 판단
- 작업 범위 결정 조건으로 사용할 수 없는 경우
    1. <>, NOT IN, NOT BETWEEN, IS NOT NULL
    2. LIKE '%?'
    3. 스토어드 함수나 다른 연산자로 인덱스 컬럼이 변형된 후 비교 시
    4. NOT-DETERMINISTIC 속성의 스토어드 함수가 비교 조건에 사용 시
    5. 데이터 타입이 서로 다른 경우
    6. 문자열 데이터 타입의 콜레이션이 다른 경우
- NULL 값도 인덱스에 저장됨. (MySQL)    